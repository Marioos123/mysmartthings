/**
 *  Copyright 2015 SmartThings
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 * 
 */
metadata {
	definition (name: "Danfoss Living Connect TRV", namespace: "Danfoss", author: "RichardP") {
		capability "Actuator"
		capability "Temperature Measurement"
		capability "Relative Humidity Measurement"
		capability "Thermostat"
		capability "Configuration"
		capability "Polling"
		capability "Sensor"
        capability "Battery"
		
		attribute "thermostatFanState", "string"

		command "switchMode"
		command "switchFanMode"
        command "quickSetCool"
        command "quickSetHeat"

		fingerprint deviceId: "0x0804"
		fingerprint inClusters: "0x43,0x40,0x44,0x31,0x80,0x46,0x81,0x72,0x8F,0x75,0x86,0x84,0xEF,0x46,0x81,0x8F"
	}

	// simulator metadata
	simulator {
//		status "off"			: "command: 4003, payload: 00"
//		status "heat"			: "command: 4003, payload: 01"
//		status "cool"			: "command: 4003, payload: 02"
//		status "auto"			: "command: 4003, payload: 03"


		// reply messages
		reply "2502": "command: 2503, payload: FF"
	}

tiles (scale: 2){
    
    		multiAttributeTile(name:"heatingSetpoint", type: "thermostat", width: 6, height: 4, canChangeIcon: true){
			tileAttribute ("device.heatingSetpoint", key: "PRIMARY_CONTROL") {
   		         attributeState("heat", unit:"C", label:'${currentValue}Â°', 
                backgroundColors:[
                    [value: 0, color: "#153591"],
                    [value: 7, color: "#1e9cbb"],
                    [value: 15, color: "#90d2a7"],
                    [value: 23, color: "#44b621"],
                    [value: 29, color: "#f1d801"],
                    [value: 35, color: "#d04e00"],
                    [value: 36, color: "#bc2323"]
               		 ]
           		 )
            }	
			tileAttribute("device.heatingSetpoint", key: "VALUE_CONTROL") {
			attributeState "heat", action:"quickSetHeat"
			}

//           tileAttribute("newSetPoint", key: "SECONDARY_CONTROL") {
//            attributeState("heat", unit:"C", label:'${currentValue}Â°')
//            }

        }

        valueTile("battery", "device.battery", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
         	tileAttribute ("device.battery", key: "PRIMARY_CONTROL"){
                        state "battery", label:'${currentValue}% battery', unit:""
        	}
        }
	
		standardTile("refresh", "device.thermostatMode", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "default", action:"polling.poll", icon:"st.secondary.refresh"
		}
		standardTile("configure", "device.configure", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "configure", label:'', action:"configuration.configure", icon:"st.secondary.configure"
		}
		
        main "heatingSetpoint"
        details(["heatingSetpoint", "newSetpoint", "battery", "refresh", "configure", "temperature"])
	}
}

def parse(String description) {
state.count = 0
    def results = []
    // log.debug("RAW command: $description")
	if (description.startsWith("Err")) {
		log.debug("An error has occurred")
		} 
    else {
       
       	def cmd = zwave.parse(description, [0x43:2])
        // log.debug "Parsed Command: $cmd"
        if (cmd) {
       	results = zwaveEvent(cmd)
		}
    }
}

// Event Generation
def zwaveEvent(physicalgraph.zwave.commands.thermostatsetpointv2.ThermostatSetpointReport cmd)
{
	def cmdScale = cmd.scale == 1 ? "F" : "C"
	def map = [:]
	map.value = convertTemperatureIfNeeded(cmd.scaledValue, cmdScale, cmd.precision)
	map.unit = getTemperatureScale()
	map.displayed = false
	switch (cmd.setpointType) {
		case 1:
			map.name = "heatingSetpoint"
			break;
		case 2:
			map.name = "coolingSetpoint"
			break;
		default:
			return [:]
	}
	// So we can respond with same format
	state.size = cmd.size
	state.scale = cmd.scale
	state.precision = cmd.precision
	map
    sendEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport cmd) {
        def map = [ name: "battery", unit: "%" ]
        if (cmd.batteryLevel == 0xFF) {  // Special value for low battery alert
                map.value = 1
                map.descriptionText = "${device.displayName} has a low battery"
                map.isStateChange = true
        } else {
                map.value = cmd.batteryLevel
                log.debug ("Battery: $cmd.batteryLevel")
        }
        // Store time of last battery update so we don't ask every wakeup, see WakeUpNotification handler
        state.lastbatt = new Date().time
        createEvent(map)
}

// Battery powered devices can be configured to periodically wake up and check in. They send this
// command and stay awake long enough to receive commands, or until they get a WakeUpNoMoreInformation
// command that instructs them that there are no more commands to receive and they can stop listening

def zwaveEvent(physicalgraph.zwave.commands.wakeupv2.WakeUpNotification cmd)
{
        def result = [createEvent(descriptionText: "${device.displayName} woke up", isStateChange: false)]

       // Only ask for battery if we haven't had a BatteryReport in a while
       if (!state.lastbatt || (new Date().time) - state.lastbatt > 24*60*60*1000) {
              result << response(zwave.batteryV1.batteryGet())
              result << response("delay 2000")  // leave time for device to respond to batteryGet
       }
        result << response(zwave.wakeUpV1.wakeUpNoMoreInformation())
        result
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicReport cmd) {
	log.debug "Zwave event received: $cmd"
}

def zwaveEvent(physicalgraph.zwave.Command cmd) {
	log.warn "Unexpected zwave command $cmd"
}

// Command Implementations
def poll() {
	delayBetween([
		zwave.thermostatSetpointV2.thermostatSetpointGet(setpointType: 1).format(),
		zwave.thermostatSetpointV2.thermostatSetpointGet(setpointType: 2).format(),
//		zwave.thermostatOperatingStateV1.thermostatOperatingStateGet().format()
	], 2300)
}

def quickSetHeat(upDown) {
	def change = upDown
    def latest = device.latestValue("heatingSetpoint")
    if (change == 1) {
    	def newSetPoint = latest + 1
        log.debug("New Set Point: $newSetPoint")
		state.setPoint = newSetPoint
        log.debug("New State Set Point: $state.setPoint")
    	setHeatingSetpoint(newSetPoint, 1000)
    }
    else if (change == 0) {
    	def newSetPoint = latest - 1
        log.debug("New Set Point: $newSetPoint")
        state.setPoint = newSetPoint
        log.debug("New State Set Point: $state.setPoint")
    	setHeatingSetpoint(newSetPoint, 1000)
    }
}

def setHeatingSetpoint(Double degrees, Integer delay) {
	log.trace "setHeatingSetpoint($degrees, $delay)"
	def deviceScale = state.scale ?: 1
	def deviceScaleString = deviceScale == 2 ? "C" : "F"
    def locationScale = getTemperatureScale()
	def p = (state.precision == null) ? 1 : state.precision

    def convertedDegrees
    if (locationScale == "C" && deviceScaleString == "F") {
    	convertedDegrees = celsiusToFahrenheit(degrees)
    } else if (locationScale == "F" && deviceScaleString == "C") {
    	convertedDegrees = fahrenheitToCelsius(degrees)
    } else {
    	convertedDegrees = degrees
    }

	delayBetween([
		zwave.thermostatSetpointV1.thermostatSetpointSet(setpointType: 1, scale: deviceScale, precision: p, scaledValue: convertedDegrees).format(),
		zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 1).format()
	], delay)
}

def configure() {
	delayBetween([
        zwave.configurationV1.configurationSet(parameterNumber:1, size:2, scaledConfigurationValue:100).format(),
        zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:[zwaveHubNodeId]).format(),    	
        zwave.wakeUpV1.wakeUpIntervalSet(seconds:300, nodeid:zwaveHubNodeId).format()
	])
}

private getStandardDelay() {
	1000
}
